import 'dart:io';

import 'package:interactive/src/main.dart';
import 'package:interactive/src/parser.dart';
import 'package:interactive/src/utils.dart';
import 'package:interactive/src/vm_service_wrapper.dart';
import 'package:interactive/src/workspace_code.dart';
import 'package:interactive/src/workspace_file_tree.dart';
import 'package:interactive/src/workspace_isolate.dart';
import 'package:logging/logging.dart';
import 'package:vm_service/vm_service.dart';

class Executor {
  static final log = Logger('Executor');

  static const _evaluateCode = 'interactiveRuntimeContext.generatedMethod()';

  final WorkspaceFileTree workspaceFileTree;
  final Writer writer;
  final VmServiceWrapper vm;
  final WorkspaceIsolate workspaceIsolate;
  var workspaceCode = const WorkspaceCode.empty();
  final inputParser = InputParser();

  Executor._(
      this.vm, this.workspaceIsolate, this.writer, this.workspaceFileTree);

  static Future<Executor> create(Writer writer,
      {required WorkspaceFileTree workspaceFileTree}) async {
    // reset to avoid syntax error etc
    _writeWorkspaceCode(const WorkspaceCode.empty(), workspaceFileTree);

    final vm = await VmServiceWrapper.create();
    final workspaceIsolate =
        await WorkspaceIsolate.create(vm, workspaceFileTree);

    return Executor._(vm, workspaceIsolate, writer, workspaceFileTree);
  }

  void dispose() {
    workspaceIsolate.dispose();
    vm.dispose();
  }

  Future<void> execute(String rawInput) async {
    if (rawInput.startsWith(_kExecuteShellPrefix)) {
      return _executeShell(rawInput);
    }
    return _executeCode(rawInput);
  }

  static const _kExecuteShellPrefix = '!';

  Future<void> _executeShell(String rawInput) async {
    await executeProcess(
      rawInput.substring(_kExecuteShellPrefix.length),
      workingDirectory: workspaceFileTree.directory,
      writer: writer,
    );
  }

  Future<void> _executeCode(String rawInput) async {
    log.info('=== Execute rawInput=$rawInput ===');

    if (rawInput.trim().isEmpty) return;

    log.info('Phase: Parse');
    final parsedInput = inputParser.parse(rawInput);
    if (parsedInput == null) return;
    workspaceCode = workspaceCode.merge(parsedInput);

    log.info('Phase: Write');
    _writeWorkspaceCode(workspaceCode, workspaceFileTree);

    log.info('Phase: ReloadSources');
    bool? forceReload;
    if (Platform.isWindows) {
      // There appears to be an issue on the Dart SDK >= 3.0 where the hot reload doesn't work if
      // the modified time of the file is the same with seconds precision
      // Possibly related to: https://github.com/dart-lang/sdk/issues/51937
      // Force=true means that the modification time of the source files is not considered.
      // See https://github.com/fzyzcjy/dart_interactive/pull/89#issuecomment-1722447792 for details
      // Also https://github.com/dart-lang/sdk/issues/53546
      forceReload = true;
    }
    final report = await vm.vmService.reloadSources(
      workspaceIsolate.isolateId,
      force: forceReload,
    );
    if (report.success != true) {
      log.warning(
          'Error: Hot reload failed, maybe because code has syntax error?');
      return;
    }

    log.info('Phase: Evaluate');
    final isolateInfo = await workspaceIsolate.isolateInfo;
    final targetId = isolateInfo.rootLib!.id!;
    final response = await vm.vmService
        .evaluate(workspaceIsolate.isolateId, targetId, _evaluateCode);
    await _handleEvaluateResponse(response);
  }

  Future<void> _handleEvaluateResponse(Response response) async {
    if (response is InstanceRef) {
      final responseString = await _instanceRefToString(response);
      if (responseString != null && responseString != 'null') {
        writer(responseString);
      }
    } else if (response is ErrorRef) {
      log.warning('Error: $response');
    } else {
      log.warning('Unknown error (response: $response)');
    }
  }

  Future<String?> _instanceRefToString(ObjRef object) async {
    if (object is InstanceRef) {
      if (object.kind == InstanceKind.kNull) return null;
      // ... can add more here
    }

    String fallback() => object.toString();

    try {
      // InstanceRef.valueAsString only works on primitive values like String,
      // int, double, etc. so for anything else we have to ask the VM to get the toString value
      final response = await vm.vmService
          .evaluate(workspaceIsolate.isolateId, object.id!, 'this.toString()');

      if (response is InstanceRef) {
        return response.valueAsString;
      }

      return fallback();
    } catch (e) {
      log.info('instanceRefToString failed e=$e');
      return fallback();
    }
  }

  static void _writeWorkspaceCode(
      WorkspaceCode workspaceCode, WorkspaceFileTree workspaceFileTree) {
    final generatedCode = workspaceCode.generate();
    File(workspaceFileTree.pathAutoGeneratedDart)
        .writeAsStringSync(generatedCode);
    log.info('generatedCode: $generatedCode');
  }
}
